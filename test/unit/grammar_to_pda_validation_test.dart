//
//  grammar_to_pda_validation_test.dart
//  JFlutter
//
//  Suite que garante a fidelidade da conversão de gramáticas livres de contexto em autômatos de pilha mantendo equivalência de linguagem.
//  Cobre gramáticas simples, produções lambda e estruturas complexas validando o PDA resultante por simulação.
//
//  Thales Matheus Mendonça Santos - October 2025
//
import 'package:flutter_test/flutter_test.dart';
import 'package:jflutter/core/models/grammar.dart';
import 'package:jflutter/core/models/production.dart';
import 'package:jflutter/core/algorithms/grammar_to_pda_converter.dart';
import 'package:jflutter/core/algorithms/pda_simulator.dart';
import 'package:jflutter/core/result.dart';
void main() {
  group('Grammar to PDA Conversion Tests', () {
    late Grammar simpleGrammar;
    late Grammar lambdaGrammar;
    late Grammar complexGrammar;

    setUp(() {
      // Test Case 1: Simple Grammar (S → aSb | ε)
      simpleGrammar = _createSimpleGrammar();

      // Test Case 2: Grammar with Lambda Productions
      lambdaGrammar = _createLambdaGrammar();

      // Test Case 3: Complex Grammar
      complexGrammar = _createComplexGrammar();
    });

    group('Conversion Tests', () {
      test('Simple grammar should convert to PDA successfully', () async {
        final result = GrammarToPDAConverter.convert(simpleGrammar);

        expect(
          result.isSuccess,
          true,
          reason: 'Simple grammar should convert to PDA successfully',
        );

        if (result.isSuccess) {
          final pda = result.data!;
          expect(
            pda.states.length,
            3,
            reason: 'PDA should have 3 states (q0, q1, q2)',
          );
          expect(
            pda.transitions.length,
            greaterThan(0),
            reason: 'PDA should have transitions',
          );
          expect(
            pda.alphabet,
            simpleGrammar.terminals,
            reason: 'PDA alphabet should match grammar terminals',
          );
        }
      });

      test('Lambda grammar should convert to PDA successfully', () async {
        final result = GrammarToPDAConverter.convert(lambdaGrammar);

        expect(
          result.isSuccess,
          true,
          reason: 'Lambda grammar should convert to PDA successfully',
        );

        if (result.isSuccess) {
          final pda = result.data!;
          expect(pda.states.length, 3, reason: 'PDA should have 3 states');
          expect(
            pda.transitions.length,
            greaterThan(0),
            reason: 'PDA should have transitions',
          );
        }
      });

      test('Complex grammar should convert to PDA successfully', () async {
        final result = GrammarToPDAConverter.convert(complexGrammar);

        expect(
          result.isSuccess,
          true,
          reason: 'Complex grammar should convert to PDA successfully',
        );

        if (result.isSuccess) {
          final pda = result.data!;
          expect(pda.states.length, 3, reason: 'PDA should have 3 states');
          expect(
            pda.transitions.length,
            greaterThan(0),
            reason: 'PDA should have transitions',
          );
        }
      });
    });

    group('Language Equivalence Tests', () {
      test('PDA should accept strings generated by simple grammar', () async {
        final conversionResult = GrammarToPDAConverter.convert(simpleGrammar);
        expect(conversionResult.isSuccess, true);

        if (conversionResult.isSuccess) {
          final pda = conversionResult.data!;

          // Test strings that should be accepted
          final testStrings = ['', 'ab', 'aabb', 'aaabbb'];

          for (final testString in testStrings) {
            final simulationResult = PDASimulator.simulateNPDA(
              pda,
              testString,
              mode: PDAAcceptanceMode.emptyStack,
            );
            expect(
              simulationResult.isSuccess,
              true,
              reason: 'PDA simulation should succeed for "$testString"',
            );

            if (simulationResult.isSuccess) {
              expect(
                simulationResult.data!.accepted,
                true,
                reason: 'PDA should accept "$testString"',
              );
            }
          }
        }
      });

      test(
        'PDA should reject strings not generated by simple grammar',
        () async {
          final conversionResult = GrammarToPDAConverter.convert(simpleGrammar);
          expect(conversionResult.isSuccess, true);

          if (conversionResult.isSuccess) {
            final pda = conversionResult.data!;

            // Test strings that should be rejected
            final testStrings = ['a', 'b', 'ba', 'aab', 'abb'];

            for (final testString in testStrings) {
              final simulationResult = PDASimulator.simulateNPDA(
                pda,
                testString,
                mode: PDAAcceptanceMode.emptyStack,
              );
              expect(
                simulationResult.isSuccess,
                true,
                reason: 'PDA simulation should succeed for "$testString"',
              );

              if (simulationResult.isSuccess) {
                expect(
                  simulationResult.data!.accepted,
                  false,
                  reason: 'PDA should reject "$testString"',
                );
              }
            }
          }
        },
      );

      test('PDA should handle lambda productions correctly', () async {
        final conversionResult = GrammarToPDAConverter.convert(lambdaGrammar);
        expect(conversionResult.isSuccess, true);

        if (conversionResult.isSuccess) {
          final pda = conversionResult.data!;

          // Test strings that should be accepted (including empty string)
          final testStrings = ['', 'a', 'aa', 'aaa'];

          for (final testString in testStrings) {
            final simulationResult = PDASimulator.simulateNPDA(
              pda,
              testString,
              mode: PDAAcceptanceMode.emptyStack,
            );
            expect(
              simulationResult.isSuccess,
              true,
              reason: 'PDA simulation should succeed for "$testString"',
            );

            if (simulationResult.isSuccess) {
              expect(
                simulationResult.data!.accepted,
                true,
                reason: 'PDA should accept "$testString"',
              );
            }
          }
        }
      });
    });

    group('Error Handling Tests', () {
      test('Empty grammar should fail conversion', () async {
        final emptyGrammar = Grammar(
          id: 'empty',
          name: 'Empty Grammar',
          terminals: {},
          nonterminals: {},
          startSymbol: '',
          productions: {},
          type: GrammarType.contextFree,
          created: DateTime.now(),
          modified: DateTime.now(),
        );

        final result = GrammarToPDAConverter.convert(emptyGrammar);
        expect(
          result.isSuccess,
          false,
          reason: 'Empty grammar should fail conversion',
        );
      });

      test('Grammar without start symbol should fail conversion', () async {
        final noStartGrammar = Grammar(
          id: 'no_start',
          name: 'No Start Grammar',
          terminals: {'a'},
          nonterminals: {'S'},
          startSymbol: '',
          productions: {
            Production(
              id: 'p1',
              leftSide: ['S'],
              rightSide: ['a'],
              isLambda: false,
              order: 1,
            ),
          },
          type: GrammarType.contextFree,
          created: DateTime.now(),
          modified: DateTime.now(),
        );

        final result = GrammarToPDAConverter.convert(noStartGrammar);
        expect(
          result.isSuccess,
          false,
          reason: 'Grammar without start symbol should fail conversion',
        );
      });
    });

    group('Analysis Tests', () {
      test('Conversion analysis should provide useful information', () async {
        final analysisResult = GrammarToPDAConverter.analyzeConversion(
          simpleGrammar,
        );

        expect(
          analysisResult.isSuccess,
          true,
          reason: 'Analysis should succeed',
        );

        if (analysisResult.isSuccess) {
          final analysis = analysisResult.data!;
          expect(
            analysis.canConvert,
            true,
            reason: 'Simple grammar should be convertible',
          );
          expect(
            analysis.productionCount,
            greaterThan(0),
            reason: 'Should have productions',
          );
          expect(
            analysis.nonTerminalCount,
            greaterThan(0),
            reason: 'Should have non-terminals',
          );
          expect(
            analysis.terminalCount,
            greaterThan(0),
            reason: 'Should have terminals',
          );
        }
      });
    });
  });
}

/// Helper functions to create test grammars

Grammar _createSimpleGrammar() {
  final productions = {
    Production(
      id: 'p1',
      leftSide: ['S'],
      rightSide: ['a', 'S', 'b'],
      isLambda: false,
      order: 1,
    ),
    Production(
      id: 'p2',
      leftSide: ['S'],
      rightSide: [],
      isLambda: true,
      order: 2,
    ),
  };

  return Grammar(
    id: 'simple',
    name: 'Simple Grammar',
    terminals: {'a', 'b'},
    nonterminals: {'S'},
    startSymbol: 'S',
    productions: productions,
    type: GrammarType.contextFree,
    created: DateTime.now(),
    modified: DateTime.now(),
  );
}

Grammar _createLambdaGrammar() {
  final productions = {
    Production(
      id: 'p1',
      leftSide: ['S'],
      rightSide: ['a', 'S'],
      isLambda: false,
      order: 1,
    ),
    Production(
      id: 'p2',
      leftSide: ['S'],
      rightSide: [],
      isLambda: true,
      order: 2,
    ),
  };

  return Grammar(
    id: 'lambda',
    name: 'Lambda Grammar',
    terminals: {'a'},
    nonterminals: {'S'},
    startSymbol: 'S',
    productions: productions,
    type: GrammarType.contextFree,
    created: DateTime.now(),
    modified: DateTime.now(),
  );
}

Grammar _createComplexGrammar() {
  final productions = {
    Production(
      id: 'p1',
      leftSide: ['S'],
      rightSide: ['A', 'B'],
      isLambda: false,
      order: 1,
    ),
    Production(
      id: 'p2',
      leftSide: ['A'],
      rightSide: ['a', 'A'],
      isLambda: false,
      order: 2,
    ),
    Production(
      id: 'p3',
      leftSide: ['A'],
      rightSide: [],
      isLambda: true,
      order: 3,
    ),
    Production(
      id: 'p4',
      leftSide: ['B'],
      rightSide: ['b', 'B'],
      isLambda: false,
      order: 4,
    ),
    Production(
      id: 'p5',
      leftSide: ['B'],
      rightSide: [],
      isLambda: true,
      order: 5,
    ),
  };

  return Grammar(
    id: 'complex',
    name: 'Complex Grammar',
    terminals: {'a', 'b'},
    nonterminals: {'S', 'A', 'B'},
    startSymbol: 'S',
    productions: productions,
    type: GrammarType.contextFree,
    created: DateTime.now(),
    modified: DateTime.now(),
  );
}
